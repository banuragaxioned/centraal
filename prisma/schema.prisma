// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  // NOTE: When using postgresql, mysql or sqlserver, uncomment the @db.Text annotations in model Account below
  // Further reading:
  // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model Tenant {
  id                     Int       @id @default(autoincrement())
  name                   String
  slug                   String    @unique
  status                 Status    @default(PUBLISHED)
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  stripeCustomerId       String?
  stripeSubscriptionId   String?
  stripePriceId          String?
  stripeCurrentPeriodEnd DateTime?

  Users      User[]       @relation("UserTenants")
  Client     Client[]
  Project    Project[]
  Milestone  Milestone[]
  Task       Task[]
  TimeEntry  TimeEntry[]
  UserGroup  UserGroup[]
  Allocation Allocation[]
  Skill      Skill[]
  SkillScore SkillScore[]
  UserRole   UserRole[]
}

model Client {
  id        Int      @id @default(autoincrement())
  name      String
  tenantId  Int
  status    Status   @default(PUBLISHED)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Project Project[]
  Tenant  Tenant    @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
}

model Project {
  id        Int             @id @default(autoincrement())
  name      String
  status    Status          @default(PUBLISHED)
  tenantId  Int
  ownerId   Int
  clientId  Int
  startdate DateTime
  enddate   DateTime?
  budget    Int?
  billable  Boolean         @default(false)
  interval  ProjectInterval
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  Milestone  Milestone[]
  Task       Task[]
  TimeEntry  TimeEntry[]
  Allocation Allocation[]
  Tenant     Tenant       @relation(fields: [tenantId], references: [id])
  Client     Client       @relation(fields: [clientId], references: [id])
  Members    User[]       @relation("ProjectMembers")
  Owner      User         @relation("UserOwnedProjects", fields: [ownerId], references: [id])

  @@index([tenantId])
  @@index([clientId])
  @@index([ownerId])
}

enum ProjectInterval {
  FIXED
  WEEKLY
  MONTHLY
  QUARTERLY
  HALFYEARLY
  YEARLY
}

enum Role {
  OWNER
  // ADMIN
  MANAGER
  USER
  INACTIVE
}

model Milestone {
  id        Int       @id @default(autoincrement())
  tenantId  Int
  projectId Int
  name      String
  budget    Int       @default(0) // Storing budget in hours
  status    Status    @default(PUBLISHED)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  startDate DateTime?
  endDate   DateTime?

  // TODO: Invoice Number reciprocal to be added to get Invoiced / Un-Invoiced Hours (INV-1234)

  Tenant    Tenant      @relation(fields: [tenantId], references: [id])
  Project   Project     @relation(fields: [projectId], references: [id])
  TimeEntry TimeEntry[]

  @@index([tenantId])
  @@index([projectId])
}

model Task {
  id        Int      @id @default(autoincrement())
  tenantId  Int
  name      String
  status    Status   @default(PUBLISHED)
  budget    Int?
  projectId Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Tenant    Tenant      @relation(fields: [tenantId], references: [id])
  Project   Project     @relation(fields: [projectId], references: [id])
  TimeEntry TimeEntry[]

  @@index([tenantId])
  @@index([projectId])
}

model TimeEntry {
  id          Int       @id @default(autoincrement())
  date        DateTime
  projectId   Int
  tenantId    Int
  userId      Int
  milestoneId Int
  taskId      Int?
  billable    Boolean   @default(false)
  time        Int // Storing time in minutes
  comments    String?
  approved    Boolean   @default(false)
  approvedBy  String?
  approvedAt  DateTime?
  status      Status    @default(PUBLISHED)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  Tenant    Tenant    @relation(fields: [tenantId], references: [id])
  Project   Project   @relation(fields: [projectId], references: [id])
  Task      Task?     @relation(fields: [taskId], references: [id])
  Milestone Milestone @relation(fields: [milestoneId], references: [id])
  User      User      @relation(fields: [userId], references: [id])

  @@index([tenantId])
  @@index([projectId])
  @@index([userId])
  @@index([milestoneId])
  @@index([taskId])
}

enum Status {
  PUBLISHED
  ARCHIVED
}

// Allocation-related
model Allocation {
  id              Int       @id @default(autoincrement())
  date            DateTime
  enddate         DateTime?
  billableTime    Int
  nonBillableTime Int
  tenantId        Int
  projectId       Int
  userId          Int
  status          Status    @default(PUBLISHED)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // If frequency is ONGOING and no enddate then it's indefinite
  // If the frequency is ONGOING and enddate is present then it's a fixed duration
  frequency AllocationFrequency @default(DAY)

  Tenant  Tenant  @relation(fields: [tenantId], references: [id])
  Project Project @relation(fields: [projectId], references: [id])
  User    User    @relation(fields: [userId], references: [id])

  @@index([tenantId])
  @@index([projectId])
  @@index([userId])
  @@index([tenantId, projectId, userId])
}

enum AllocationFrequency {
  DAY
  ONGOING
}

model SkillScore {
  id        Int      @id @default(autoincrement())
  userId    Int
  skillId   Int
  tenantId  Int
  level     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Tenant Tenant @relation(fields: [tenantId], references: [id])
  Skill  Skill  @relation(fields: [skillId], references: [id], onDelete: Cascade)
  User   User   @relation(fields: [userId], references: [id])

  @@index([tenantId])
  @@index([skillId])
  @@index([userId])
}

model Skill {
  id        Int      @id @default(autoincrement())
  name      String
  tenantId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Tenant Tenant @relation(fields: [tenantId], references: [id])

  SkillScore SkillScore[]

  @@index([tenantId])
}

// Additional User meta-data
model UserRole {
  id        Int      @id @default(autoincrement())
  role      Role     @default(USER)
  userId    Int
  tenantId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Tenant Tenant @relation(fields: [tenantId], references: [id])
  User   User   @relation(fields: [userId], references: [id])

  @@unique([role, userId, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@index([userId, tenantId]) // Added an index on both fields to optimize queries involving both fields
}

model UserGroup {
  id        Int      @id @default(autoincrement())
  name      String
  tenantId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users     User[]

  Tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId])
}

enum UserStatus {
  ACTIVE
  INACTIVE
  DELETED
}

// NextAuth-related
model User {
  id            Int        @id @default(autoincrement())
  name          String?
  email         String     @unique
  timezone      String     @default("UTC")
  emailVerified DateTime?
  image         String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  allocationId  Int?
  status        UserStatus @default(ACTIVE)

  TenantId      Tenant[]     @relation("UserTenants")
  UserGroup     UserGroup[]
  accounts      Account[]
  sessions      Session[]
  Roles         UserRole[]
  Allocation    Allocation[]
  SkillScore    SkillScore[]
  TimeEntry     TimeEntry[]
  Project       Project[]    @relation("ProjectMembers")
  OwnedProjects Project[]    @relation("UserOwnedProjects")

  @@index([allocationId])
}

model Session {
  id           Int      @id @default(autoincrement())
  sessionToken String   @unique
  userId       Int
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Necessary for Next auth
model Account {
  id                Int     @id @default(autoincrement())
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}
